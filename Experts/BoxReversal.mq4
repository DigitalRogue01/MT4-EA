//+------------------------------------------------------------------+
//|                                                 BoxReversal.mq4  |
//|           All-in-One EA - Clean MQL4-Compatible Build            |
//+------------------------------------------------------------------+
#property strict
#property copyright "Generated by ChatGPT"

#include <stdlib.mqh>
#include <stderror.mqh>

//---- input parameters
input double RiskPercent        = 2.0;    // Risk per trade
input int    ATR_Period         = 14;
input int    ADX_Period         = 14;
input double ADX_Minimum        = 25.0;
input double MinDIDistance      = 6.0;
input double PSAR_Step          = 0.02;
input double PSAR_Max           = 0.2;
input double ReversalZonePct    = 0.10;   // Green band % (each band)

//---- internal vars
double boxHigh, boxLow, boxRange;
double upperZoneStart, upperZoneEnd;
double lowerZoneStart, lowerZoneEnd;
bool tradeTaken = false;
bool scaledOut = false;
int activeTradeTicket = -1;
double entryPrice = 0;
double stopLossPrice = 0;
double scaleOutPrice = 0;

//+------------------------------------------------------------------+
int OnInit()
{
   Print("[BoxReversal] Initialized at ", TimeToString(TimeCurrent(), TIME_DATE | TIME_MINUTES));
   return INIT_SUCCEEDED;
}

void OnTick()
{
   static datetime lastBarTime = 0;
   if (Time[0] == lastBarTime) return;
   lastBarTime = Time[0];

   CalculateBox();

   if (!PositionExists())
   {
      scaledOut = false;
      activeTradeTicket = -1;
      EvaluateTrade();
   }
   else
   {
      ManageTrade();
   }
}

void CalculateBox()
{
   boxHigh = iHigh(Symbol(), PERIOD_D1, 1);
   boxLow  = iLow(Symbol(), PERIOD_D1, 1);
   boxRange = boxHigh - boxLow;

   double zoneSize = boxRange * ReversalZonePct;

   upperZoneStart = boxHigh;
   upperZoneEnd   = boxHigh - zoneSize;
   lowerZoneStart = boxLow;
   lowerZoneEnd   = boxLow + zoneSize;

   // Draw full range box first (underlay)
   DrawBox("MainBox", boxLow, boxHigh, clrSilver);
   DrawBox("UpperReversal", upperZoneEnd, upperZoneStart, clrGreen);
   DrawBox("LowerReversal", lowerZoneStart, lowerZoneEnd, clrGreen);
}

void EvaluateTrade()
{
   double psar = iSAR(NULL, 0, PSAR_Step, PSAR_Max, 1);
   double adx = iADX(NULL, 0, ADX_Period, PRICE_CLOSE, MODE_MAIN, 0);
   double diPlus = iADX(NULL, 0, ADX_Period, PRICE_CLOSE, MODE_PLUSDI, 0);
   double diMinus = iADX(NULL, 0, ADX_Period, PRICE_CLOSE, MODE_MINUSDI, 0);

   double atr = iATR(NULL, 0, ATR_Period, 1);
   double stopLoss = atr * 1.5;
   double riskAmount = AccountBalance() * RiskPercent / 100.0;
   double contractSize = MarketInfo(Symbol(), MODE_LOTSIZE);
   double lotSize = NormalizeDouble((riskAmount / (stopLoss / Point)) / contractSize, 2);

   string reason = "";

   if (Close[1] < lowerZoneStart && Close[1] > lowerZoneEnd && Low[1] < lowerZoneEnd)
   {
      if (adx >= ADX_Minimum && (diPlus - diMinus) >= MinDIDistance && Close[1] > psar)
      {
         int ticket = OrderSend(Symbol(), OP_BUY, lotSize, Ask, 3, Bid - stopLoss * Point, 0, "BoxReversal Buy", 0, 0, clrBlue);
         if (ticket > 0)
         {
            tradeTaken = true;
            activeTradeTicket = ticket;
            entryPrice = Ask;
            stopLossPrice = Bid - stopLoss * Point;
            scaleOutPrice = entryPrice + atr;
         }
         reason = "BUY - Reversal Confirmed";
      }
      else
      {
         if (adx < ADX_Minimum)
            reason = "BUY Skipped - ADX too low";
         else if ((diPlus - diMinus) < MinDIDistance)
            reason = "BUY Skipped - DI gap too small";
         else if (Close[1] < psar)
            reason = "BUY Skipped - PSAR not aligned";
         else
            reason = "BUY Skipped - Unknown reason";
      }
   }
   else if (Close[1] < upperZoneStart && Close[1] > upperZoneEnd && High[1] > upperZoneStart)
   {
      if (adx >= ADX_Minimum && (diMinus - diPlus) >= MinDIDistance && Close[1] < psar)
      {
         int ticket = OrderSend(Symbol(), OP_SELL, lotSize, Bid, 3, Ask + stopLoss * Point, 0, "BoxReversal Sell", 0, 0, clrRed);
         if (ticket > 0)
         {
            tradeTaken = true;
            activeTradeTicket = ticket;
            entryPrice = Bid;
            stopLossPrice = Ask + stopLoss * Point;
            scaleOutPrice = entryPrice - atr;
         }
         reason = "SELL - Reversal Confirmed";
      }
      else
      {
         if (adx < ADX_Minimum)
            reason = "SELL Skipped - ADX too low";
         else if ((diMinus - diPlus) < MinDIDistance)
            reason = "SELL Skipped - DI gap too small";
         else if (Close[1] > psar)
            reason = "SELL Skipped - PSAR not aligned";
         else
            reason = "SELL Skipped - Unknown reason";
      }
   }
   else
      reason = "No Entry - Outside Zones";

Comment(
     "[BoxReversal] " + reason + "\n" +
     "BoxHigh: " + DoubleToString(boxHigh, 5) + "  BoxLow: " + DoubleToString(boxLow, 5) + "\n" +
     "ADX: " + DoubleToString(adx, 2) + "  DI+: " + DoubleToString(diPlus, 2) + 
     "  DI-: " + DoubleToString(diMinus, 2) + "  DI Gap: " + DoubleToString(MathAbs(diPlus - diMinus), 2) + "\n" +
     "PSAR: " + DoubleToString(psar, 5) + "  ATR: " + DoubleToString(atr, 5) + "\n" +
     "Lots: " + DoubleToString(lotSize, 2) + "  ScaleOutPrice: " + DoubleToString(scaleOutPrice, 5)
);

}

void ManageTrade()
{
   for (int i = 0; i < OrdersTotal(); i++)
   {
      if (OrderSelect(i, SELECT_BY_POS, MODE_TRADES) && OrderTicket() == activeTradeTicket)
      {
         double currentPrice = OrderType() == OP_BUY ? Bid : Ask;

         if (!scaledOut)
         {
            if ((OrderType() == OP_BUY && currentPrice >= scaleOutPrice) ||
                (OrderType() == OP_SELL && currentPrice <= scaleOutPrice))
            {
               double newStop = entryPrice;
               if (OrderModify(OrderTicket(), OrderOpenPrice(), newStop, 0, 0, clrOrange))
               {
                  double halfLot = NormalizeDouble(OrderLots() / 2.0, 2);
                  if (OrderClose(OrderTicket(), halfLot, currentPrice, 3, clrYellow))
                  {
                     scaledOut = true;
                     Print("[ScaleOut] Modified SL to breakeven and closed half at price: ", DoubleToString(currentPrice, 5));
                  }
                  else
                  {
                     Print("[ScaleOut] ERROR: Failed to close half lot at price: ", DoubleToString(currentPrice, 5));
                  }
               }
               else
               {
                  Print("[ScaleOut] ERROR: Failed to move stop loss to breakeven.");
               }
            }
         }

         double psar = iSAR(NULL, 0, PSAR_Step, PSAR_Max, 1);
         if (scaledOut && ((OrderType() == OP_BUY && Close[1] < psar) ||
             (OrderType() == OP_SELL && Close[1] > psar)))
         {
            OrderClose(OrderTicket(), OrderLots(), currentPrice, 3, clrViolet);
            activeTradeTicket = -1;
            scaledOut = false;
         }
      }
   }
}

bool PositionExists()
{
   for (int i = 0; i < OrdersTotal(); i++)
   {
      if (OrderSelect(i, SELECT_BY_POS, MODE_TRADES))
      {
         if (OrderSymbol() == Symbol() && OrderMagicNumber() == 0)
            return true;
      }
   }
   return false;
}

void DrawBox(string name, double price1, double price2, color clr)
{
   datetime dayStart = iTime(Symbol(), PERIOD_D1, 1);           // Start of previous day
   datetime dayEnd   = iTime(Symbol(), PERIOD_D1, 0);           // Start of current day
   string objName = name + "_" + TimeToStr(dayStart, TIME_DATE);

   ObjectDelete(objName);
   ObjectCreate(objName, OBJ_RECTANGLE, 0, dayStart, price1, dayEnd, price2);
   ObjectSet(objName, OBJPROP_COLOR, clr);
   ObjectSet(objName, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSet(objName, OBJPROP_WIDTH, 1);
   ObjectSet(objName, OBJPROP_BACK, true);
   ObjectSet(objName, OBJPROP_CORNER, 0);
   ObjectSet(objName, OBJPROP_RAY_RIGHT, false);
}
